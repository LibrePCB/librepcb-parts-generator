eval 'exec `which perl` -S $0 ${1+"$@"}'
   if 0;

#/**********************************************************************/
#/*                                                                    */
#/*             -------                                                */
#/*            /   SOC  \                                              */
#/*           /    GEN   \                                             */
#/*          /    TOOL    \                                            */
#/*          ==============                                            */
#/*          |            |                                            */
#/*          |____________|                                            */
#/*                                                                    */
#/*  Converts a kicad  symbol source file into a cvsfile               */
#/*                                                                    */
#/*                                                                    */
#/*  Author(s):                                                        */
#/*      - John Eaton, z3qmtr45@gmail.com                              */
#/*                                                                    */
#/**********************************************************************/
#/*                                                                    */
#/*    Copyright (C) <2020>  <Ouabache Design Works>                   */
#/*                                                                    */
#/*  This source file may be used and distributed without              */
#/*  restriction provided that this copyright statement is not         */
#/*  removed from the file and that any derivative work contains       */
#/*  the original copyright notice and the associated disclaimer.      */
#/*                                                                    */
#/*  This source file is free software; you can redistribute it        */
#/*  and/or modify it under the terms of the GNU Lesser General        */
#/*  Public License as published by the Free Software Foundation;      */
#/*  either version 2.1 of the License, or (at your option) any        */
#/*  later version.                                                    */
#/*                                                                    */
#/*  This source is distributed in the hope that it will be            */
#/*  useful, but WITHOUT ANY WARRANTY; without even the implied        */
#/*  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR           */
#/*  PURPOSE.  See the GNU Lesser General Public License for more      */
#/*  details.                                                          */
#/*                                                                    */
#/*  You should have received a copy of the GNU Lesser General         */
#/*  Public License along with this source; if not, download it        */
#/*  from http://www.opencores.org/lgpl.shtml                          */
#/*                                                                    */
#/**********************************************************************/



############################################################################
# General PERL config
############################################################################
use Getopt::Long;
use English;
use File::Basename;
use Cwd;
$OUTPUT_AUTOFLUSH = 1; # set autoflush of stdout to TRUE.




############################################################################
### Process the options
############################################################################

Getopt::Long::config("require_order", "prefix=-");
GetOptions("h",
           "group=s" => \$group,
	   "Part=s" => \$Part
) || die "(use 'sym2csv -h' for help)";









##############################################################################
## Help option
##############################################################################
if ( ($opt_h eq "1") ) 
  { print "\n type test filename.lib";
    print "\n";
    exit 1;
  }



#############################################################################
## 
##  open intel hex  file  and read into array
## 
#############################################################################

my $home           = cwd();

my $cmp_path       = "${home}/${group}";


mkdir $cmp_path,0755   unless( -e $cmp_path );

my $low_x  = 0;
my $hi_y   = 0;
my $pin_tiddle = 1; 

my $in_polygon = 0;
my $polygon_x  = 0;
my $polygon_y  = 0;

my $result =  uuid();


my $cmpcat_val;
unless($Part){ $Part = 1;}



  my $prog_name         = $ARGV[0];

  my $input_file   = ${prog_name};

  $_ = $prog_name; 
      if(/(\S+)\/(\S+).sym/)

        {
	$cmpcat_file = "$1/cmpcat.uuid";
        open   FILE, $cmpcat_file;
        while(<FILE>)
             {
	     push @cmpcat_store, $_  ;
             $cmpcat_val = $_;
             }
        }


  my $output_file  = "${home}/sym/${result}/symbol.lp";







  print "                          Reading kicad     File  $input_file\n";  





  open  VERILOG , ">  $output_file";
  open   FILE, $input_file;
  while(<FILE>){push @intel_hex, $_  ;}


  printf VERILOG ("(librepcb_symbol %s\n",$result);


my $cmp_name;
my $footprint_name;
my $ver_a;
my $ver_b;
my $ver_c;
my $ver_d;


my $cmp_reference;
my $draw_pinnumber;
my $draw_pinname;
my $unit_count;
my $units_locked;
my $option_flag;


#
# Collect part data and print out header
#
#
#
foreach $line (@intel_hex)
       {
       $_ = $line; 
       if(/DEF (\S+) (\S+) (\S+) (\S+) (\S+) (\S+) (\S+) (\S+) (\S+)/)
          { 

            $cmp_name       = $1;
            $cmp_reference  = $2;
            $draw_pinnumber = $5;
            $draw_pinname   = $6;
            $unit_count     = $7;
            $units_locked   = $8;
            $option_flag    = $9;

          }
       }


printf("                          processing %s\n",$cmp_name);
#unless ($cmp_name){printf("Warning Will Robinson\n");}

printf VERILOG (" (name \"%s\")\n",$cmp_name);



foreach $line (@intel_hex)
       {
       $_ = $line; 
       if(/F2 "(\S+)"/)
          { 

            $footprint_name       = $1;
          }
       }











#
# Parse out and print graphics and pins
#
#
#











#
# Pins
#

foreach $line (@intel_hex)
    {
    $_ = $line; 
    if(/(\S+) (\S+) (\S+) (\S+) (\S+) (\S+) (\S+) (\S+) (\S+) (\S+) (\S+)/) 
      {
      if($1 eq "X")
        {

        my $pin_uuid = uuid();

        my $name         = $2;
	my $number       = $3;
        my $posx         = $4;
	my $posy         = $5;
        my $length       = $6;
        my $side         = $7;
        my $Snum         = $8;
        my $Snom         = $9;
        my $unit         = $10;
	my $convert      = $11;

        $row_adj = ($posy + 5000)/10;
        $orig_name = $name;
        $name =~ s/,/_/;
        $name =~ s/,/_/;
        $name =~ s/,/_/;
        $name =~ s/,/_/;
        $name =~ s/,/_/;

  if(1)
  {


        if($name eq "~")
	{
	$name = "n${pin_tiddle}";
	$pin_tiddle = $pin_tiddle +1;
	}

        if($name eq "~~")
	{
	$name = "n${pin_tiddle}";
	$pin_tiddle = $pin_tiddle +1;
	}

        if($name eq "#")
	{
	$name = "n${pin_tiddle}";
	$pin_tiddle = $pin_tiddle +1;
	}

        if($name eq ":")
	{
	$name = "n${pin_tiddle}";
	$pin_tiddle = $pin_tiddle +1;
	}


        if ($orig_name ne $name)
	  {
           print " Mapped ${orig_name}  into ${name}\n";  
          }
	  
        my $xfer = "${side}::${row_adj}::${name}::${number}::${posx}::${posy}::${length}::${side}::${Snum}::${Snom}::${unit}::${convert}";
	push  @dev_pins, $xfer;


        }
      }
    }
}



















if(1)
{
 $output_file  = "${home}/${group}/F${cmp_name}.csv";

  open  COMPONENT , ">  $output_file";

          printf COMPONENT ("DEF,%s\n",$cmp_name);
          printf COMPONENT ("UNITS,%s\n",$unit_count);
          printf COMPONENT ("FOOT,%s\n",$footprint_name);



  @dev_pins = trim_sort(@dev_pins);
  while($item = pop(@dev_pins))
       {

       $_ = $item; 
       if(/(\S+)::(\S+)::(\S+)::(\S+)::(\S+)::(\S+)::(\S+)::(\S+)::(\S+)::(\S+)::(\S+)::(\S+)/)
         {
	 $pin_side    = $1;
	 $pin_row     = $2;
         $pin_name    = $3;
	 $pin_number  = $4;
	 $pin_posx    = $5;
	 $pin_posy    = $6;
	 $pin_length  = $7;
	 $pin_side    = $8;
	 $pin_Snum    = $9;
	 $pin_Snom    = $10;
	 $pin_unit    = $11;
	 $pin_convert = $12;

         printf COMPONENT ("PIN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",$pin_name,$pin_side,$pin_number,$pin_posx,$pin_posy,$pin_length,$pin_side,$pin_Snum,$pin_Snom,$pin_unit,$pin_convert);


         }

       }



 



}


#############################################################################
## 
##  convert 0-9,A-F to decimal or 0 if out of range
## 
#############################################################################


sub cvt { 

$temp =    ord($_[0]);
if( $temp <= 48) { return 0 }
if( $temp <= 58) { return $temp - 48 }
if( $temp <= 64) { return 0 }
if( $temp <= 70) { return ($temp - 65)+10 }
return 0;



}







#############################################################################
## 
##  Create random UUID
## 
#############################################################################


sub uuid { 

  my $uuid1 = rand(65536);
  my $uuid2 = rand(65536);
  my $uuid3 = rand(65536);
  my $uuid4 = rand(4096);
  my $uuid5 = rand(4096);
  my $uuid6 = rand(65536);
  my $uuid7 = rand(65536);
  my $uuid8 = rand(65536);

my $temp =   sprintf("%04x%04x-%04x-4%03x-8%03x-%04x%04x%04x", $uuid1,$uuid2,$uuid3,$uuid4,$uuid5,$uuid6,$uuid7,$uuid8 );

 
return $temp;



}







#############################################################################
## 
##  distance between
## 
#############################################################################


sub distance { 
  my ($x1,$x2) = @_;

if(($x1>=0)&&($x2 >= 0))
  {
  $diff = abs($x1-$x2);
  }
  elsif(($x1>=0)&&($x2 < 0))
  {
  $diff = $x1-$x2;
  }
  elsif(($x1<0)&&($x2 >= 0))
  {
  $diff = $x2-$x1;
  }
  else
  {
  $diff = abs($x1-$x2);
  }

return $diff;

}





#############################################################################
## 
##  compute angle
## 
#############################################################################


sub comp_angle { 
  my ($posx,$posy,$radius,$start,$end,$startpointx,$startpointy,$endpointx,$endpointy) = @_;




#printf ("Angle midpt  %6.2f   %6.2f  Radius  %6.2f  StartA %6.1f EndA %6.1f  Start Pt %6.2f,%6.2f  EndPt %6.2f,%6.2f\n",
#          $posx,$posy, $radius,$start,$end,$startpointx,$startpointy,$endpointx,$endpointy   );





        if(($start < 0)&&($end >= 0))
	{
        $angle = $end - $start;
	
	if ($angle >180){$angle = -1*${angle};}
# 	if ($angle < -180){$angle = 180+  ${angle};
#printf ("Angle1  = %s   %s  %s   \n",$angle , $start , $end  );
}

        if(($start >= 0)&&($end <0))
	{
        $angle =360-( $start - $end);
	if ($angle >=180){$angle = ${angle}-180;}
		if ($angle < -180){$angle = 180+  ${angle};}
#printf ("Angle2  = %s   %s  %s   \n",$angle , $start , $end  );
}


        if(($start >= 0)&&($end >=0))
	{
        $angle = $end - $start;
	if ($angle >=180){$angle = ${angle}-180;}
 	if ($angle < -180){$angle = 180+  ${angle}}
#	printf ("Angle3  = %s   %s  %s   \n",$angle , $start , $end  );
}


       if(($start < 0)&&($end <0))
	{
        $angle =-1*( $start + $end);
	if ($angle < -180){$angle = ${angle}+180;}
#printf ("Angle4  = %s   %s  %s   \n",$angle , $start , $end  );
        }


	if ($angle >= 360){$angle = ${angle}- 360;}



return $angle;

}





#############################################################################
## 
##  compute angle
## 
#############################################################################


sub camp_angle { 
  my ($posx,$posy,$radius,$start,$end,$startpointx,$startpointy,$endpointx,$endpointy) = @_;




#printf ("Angle midpt  %6.2f   %6.2f  Radius  %6.2f  StartA %6.1f EndA %6.1f  Start Pt %6.2f,%6.2f  EndPt %6.2f,%6.2f\n",
#          $posx,$posy, $radius,$start,$end,$startpointx,$startpointy,$endpointx,$endpointy   );


$angle_start  = norm($start);
$angle_end    = norm($end);

$dist_x = distance($startpointx,$endpointx );
$dist_y = distance($startpointy,$endpointy );

if($dist_x == 0)
  {
  $L_angle = 180;
  }
else
  {
  $slope  = $dist_y/$dist_x;
  $exp    = $slope * ($posx - $startpointx)+$startpointy;
  if($exp > $posy)
    {
    $L_angle = abs($angle_start - $angle_end);
    }
  else
    {
    $L_angle = 360 -abs($angle_start - $angle_end);
    }

}



#printf ("Angle midpt  %6.2f   %6.2f  Radius  %6.2f  StartA %6.1f EndA %6.1f\n",
#          $posx,$posy, $radius,$start,$end );

#printf ("A   Start Pt %6.2f,%6.2f  EndPt %6.2f,%6.2f angle %6.2f\n",
#          $startpointx,$startpointy,$endpointx,$endpointy ,$L_angle  );





return $angle;

}






#############################################################################
## 
##  normalize
## 
#############################################################################


sub norm { 
  my ($x1) = @_;

if($x1>=360)
  {
  $ang = $x1-360;
  }
  elsif($x1<0)
  {
  $ang = $x1+360;
  }
  else
  {
  $ang = $x1;
  }

return $ang;

}



sub trim_sort {
   my @output_files  = @_;
   my %trim = ();
   foreach my $descriptor (@output_files) { $trim{$descriptor}  = 1; }
   my @k = keys %trim;
   @output_files =  sort(sort @k);  
   return(@output_files);
   }


1


