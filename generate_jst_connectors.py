"""
    Generate JST wire-to-board female connectors

    see https://en.wikipedia.org/wiki/JST_connector
"""
from array import array
from os import makedirs, path
from struct import pack
from uuid import uuid4

from typing import Callable, Iterable, List, Optional, Tuple
from venv import create

from common import format_float as ff, generate_courtyard
from common import init_cache, now, save_cache
from entities.common import (
    Align, Angle, Author, Category, Created, Deprecated, Description, Fill, GrabArea, Height, Keywords, Layer, Length,
    Name, Polygon, Position, Rotation, Text, Value, Version, Vertex, Width
)
from entities.component import (
    Clock, Component, DefaultValue, ForcedNet, Gate, Negated, Norm, PinSignalMap, Prefix, Required, Role, SchematicOnly,
    Signal, SignalUUID, Suffix, SymbolUUID, TextDesignator, Variant
)
from entities.package import (
    AutoRotate, Drill, FootprintPad, LetterSpacing, LineSpacing, Mirror, Package, PackagePad, Footprint, Shape, Side, Size, StrokeText, StrokeWidth
)
from entities.device import (
    ComponentPad,
    ComponentUUID,
    Device,
    PackageUUID
)
from entities.symbol import Pin as SymbolPin
from entities.symbol import Symbol

generator = 'librepcb-parts-generator (generate_jst_connectors.py)'

naming_pattern = "JST SH 0x0"

KIND_SOCKET = 'pinsocket'

pkg_text_height = Height(1.0)
pkg_text_stroke_width = StrokeWidth(0.2)

uuid_cache_file = 'uuid_cache_jst_connectors.csv'
uuid_cache = init_cache(uuid_cache_file)

class SeriesInfo:
    def __init__(self, kind: str, full_name: str, url: str, author: str, version: str, create_date: Optional[str]):
        self.kind = kind
        self.full_name = full_name
        self.url = url
        self.author = author
        self.version = version
        self.create_date = create_date
    
    def description(self, circuits: int) -> Description:
        return Description(f'JST {self.kind} {circuits} Connector\n'
            f'{self.full_name}\n'
            f'Referenced from {self.url}\n'
            f'Generated by {generator}'
        )
    
    def keywords(self, circuits: int) -> Keywords:
        return Keywords('connector, jst, ' + f'jst-{self.kind}-{circuits}')

    def name(self, circuits: int) -> Name:
        return Name(f'JST {self.kind} {circuits} Connector')

    def category(self) -> Category:
        pass

# we need some way of looking up the Connectors from LibrePCB Connectors library.
def lookup_component(rows: int, circuits: int) -> str:
    with open(path.join('uuid_cache_connectors.csv'), 'r') as f:
        lines = f.readlines()
        for l in lines:
            if l.startswith(f'cmp-pinsocket-{rows}x{circuits}-cmp,'):
                return l.split(',')[1][:-1]

        print(f'error! could not find connector symbol for {rows}x{circuits}')
        exit(1)

def lookup_component_signal(rows: int, circuits: int) -> List[str]:
    found = [None] * circuits
    with open(path.join('uuid_cache_connectors.csv'), 'r') as f:
        lines = f.readlines()
        for l in lines:
            for i in range(circuits):
                if l.startswith(f'cmp-pinsocket-{rows}x{circuits}-signal-{i},'):
                    found[i] = l.split(',')[1][:-1]

        for i in range(circuits):
            if found[i] == None:
                print(f'error! could not find pin connector symbol for {rows}x{circuits} signal {i}')
                exit(1)

        return found

def uuid(category: str, kind: str, variant: str, identifier: str) -> str:
    key = '{}-{}-{}-{}'.format(category, kind, variant, identifier).lower().replace(' ', '~')
    if key not in uuid_cache:
        uuid_cache[key] = str(uuid4())
    return uuid_cache[key]

def write_pkg(dirpath: str, pkg: Package) -> None:
    pkg_dir_path = path.join(dirpath + '/pkg', pkg.uuid)
    if not (path.exists(pkg_dir_path) and path.isdir(pkg_dir_path)):
        makedirs(pkg_dir_path)
    with open(path.join(pkg_dir_path, '.librepcb-pkg'), 'w') as f:
        f.write('0.1\n')
    with open(path.join(pkg_dir_path, 'package.lp'), 'w') as f:
        f.write(str(pkg))
        f.write('\n')
    print(f'wrote package {pkg.name.value}: {pkg.uuid}')

def write_cmp(dirpath: str, cmp: Component) -> None:
    cmp.serialize(dirpath + '/cmp')
    print(f'wrote component {cmp.name.value}: {cmp.uuid}')

def write_dev(dirpath: str, dev: Device) -> None:
    dev.serialize(dirpath + '/dev')
    print(f'wrote device {dev.name.value}: {dev.uuid}')

def polygon_rect(polygon: Polygon, x: float, y: float, w: float, h: float) -> None:
    polygon.add_vertex(Vertex(Position(x, y), Angle(0)))
    polygon.add_vertex(Vertex(Position(x + w, y), Angle(0)))
    polygon.add_vertex(Vertex(Position(x + w, y + h), Angle(0)))
    polygon.add_vertex(Vertex(Position(x, y + h), Angle(0)))
    polygon.add_vertex(Vertex(Position(x, y), Angle(0)))

# https://www.jst-mfg.com/product/pdf/eng/eXH.pdf
# pitch: 2.5mm
def gen_jst_pkg_xh_tht_top(
    pads: int,
    type: SeriesInfo
) -> Package:
    pitch = 2.5
    pass


# https://www.jst-mfg.com/product/pdf/eng/eSH.pdf?634ed01abb790
# pitch: 1.0mm
# pad: 0.6mm x 1.55mm
# support-pad: 1.2mm x 1.8mm
def gen_jst_pkg_sh(
    pads: int,
    type: SeriesInfo
) -> Package:
    pitch = 1.0
    pad_w = 0.6
    pad_h = 1.55
    support_pad_w = 1.2
    support_pad_h = 1.8

    pad_offset_x = 1.3
    pad_offset_y = -2.525

    pad_pos = lambda i: Position(pad_offset_x + (i * pitch), pad_offset_y)
    last_pad_pos_x = pad_offset_x + ((pads - 1) * pitch)

    support_pad_offset_x = last_pad_pos_x + pad_offset_x

    center_x = support_pad_offset_x/2

    name_offset_y = 1.1
    value_offset_y = -3.6

    def _uuid(identifier: str) -> str:
        return uuid('pkg', KIND_SOCKET, f"SH-{pads}", identifier)

    # generate pkg
    package = Package(
        _uuid('pkg'),
        type.name(pads),
        type.description(pads),
        type.keywords(pads),
        Author(type.author),
        Version(type.version),
        Created(type.create_date),
        Deprecated(False),
        Category(_uuid('hmm category'))
    )

    footprint = Footprint(
        _uuid(f'footprint-default'),
        Name("default"),
        Description("todo")
    )

    # symbolic pad
    for pad in range(pads):
        id = _uuid(f'pad-{pad + 1}')
        package.add_pad(PackagePad(
            id,
            Name(str(pad + 1))
        ))
        footprint.add_pad(FootprintPad(
            id,
            Side.TOP,
            Shape.RECT,
            pad_pos(pad),
            Rotation(0),
            Size(pad_w, pad_h),
            Drill(0)
        ))
    
    spad1 = FootprintPad(
        _uuid('support-pad-0'),
        Side.TOP,
        Shape.RECT,
        Position(0, 0),
        Rotation(0),
        Size(support_pad_w, support_pad_h),
        Drill(0)
    )
    spad2 = FootprintPad(
        _uuid('support-pad-1'),
        Side.TOP,
        Shape.RECT,
        Position(last_pad_pos_x + pad_offset_x, 0),
        Rotation(0),
        Size(support_pad_w, support_pad_h),
        Drill(0)
    )
    package.add_pad(PackagePad(_uuid('support-pad-0'), Name("NC0")))
    package.add_pad(PackagePad(_uuid('support-pad-1'), Name("NC1")))
    footprint.add_pad(spad1)
    footprint.add_pad(spad2)

    # add outline
    polygon_shroud = Polygon(
        _uuid("polygon-shroud"),
        Layer("top_documentation"),
        Width(0.25),
        Fill(False),
        GrabArea(False)
    )

    silkscreen_width = (pads - 1) * pitch + 2.6
    polygon_rect(polygon_shroud, -0.3, 0.6, silkscreen_width + 0.3, -2.9)

    polygon_grab = Polygon(
        _uuid("polygon-grab"),
        Layer("top_hidden_grab_areas"),
        Width(0.25),
        Fill(True),
        GrabArea(True)
    )

    polygon_rect(polygon_grab, -0.5, 0.8, silkscreen_width + 0.7, -4.0)

    # add courtyard
    footprint.add_polygon(polygon_shroud)
    footprint.add_polygon(polygon_grab)

    # add labels
    name_text = StrokeText(
        _uuid('text-name'),
        Layer('top_names'),
        pkg_text_height,
        pkg_text_stroke_width,
        LetterSpacing.AUTO,
        LineSpacing.AUTO,
        Align('center bottom'),
        Position(center_x, name_offset_y),
        Rotation(0),
        AutoRotate(True),
        Mirror(False),
        Value('{{NAME}}')
    )
    value_text = StrokeText(
        _uuid('text-value'),
        Layer('top_values'),
        pkg_text_height,
        pkg_text_stroke_width,
        LetterSpacing.AUTO,
        LineSpacing.AUTO,
        Align('center top'),
        Position(center_x, value_offset_y),
        Rotation(0),
        AutoRotate(True),
        Mirror(False),
        Value('{{VALUE}}')
    )
    footprint.add_text(name_text)
    footprint.add_text(value_text)

    package.add_footprint(footprint)

    return package

# generate a device.
# takes in the package, and binds it to a pinsocket (from LibrePCB Connectors)
# component with the same number of pins.
# All NC pads should be added last to the 
def gen_jst_dev(
    package: Package,
    circuits: int,
    ncs: int,
    type: SeriesInfo
) -> Device:
    def _uuid(identifier: str) -> str:
        return uuid('dev', KIND_SOCKET, f"{type.kind}-{circuits}", identifier)

    component_uuid = lookup_component(1, circuits)
    signal_uuids = lookup_component_signal(1, circuits)

    dev = Device(
        _uuid('dev'),
        type.name(circuits),
        type.description(circuits),
        type.keywords(circuits),
        Author(type.author),
        Version(type.version),
        Created(type.create_date),
        Deprecated(False),
        Category(_uuid("none")),
        ComponentUUID(component_uuid),
        PackageUUID(package.uuid)
    )    

    for i in range(circuits):
        dev.add_pad(ComponentPad(package.pads[i].uuid, SignalUUID(signal_uuids[i])))

    for i in range(ncs):
        dev.add_pad(ComponentPad(package.pads[circuits + i].uuid, SignalUUID('none')))

    return dev

# generates a complete jst female connector, 
def generate_jst(
    dirpath: str, 
    available_circuits: List[int],
    series: str,
    full_name: str,
    url: str,
    author: str,
    rows: int,
    version: str,
    create_date: Optional[str]
) -> None:
    assert rows == 1

    type = SeriesInfo(series, full_name, url, author, version, create_date)

    for pads in available_circuits:
        pkg = gen_jst_pkg_sh(pads, type)
        dev = gen_jst_dev(pkg, pads, 2, type)
        # create pkg
        write_pkg(dirpath, pkg)
        write_dev(dirpath, dev)

if __name__ == '__main__':
    def _make(dirpath: str) -> None:
        if not (path.exists(dirpath) and path.isdir(dirpath)):
            makedirs(dirpath)
    _make('out')
    _make('out/jst-connectors')

    generate_jst(
        dirpath='out/jst-connectors',
        available_circuits=[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 20],
        series='SH',
        full_name='SSH-003-T-P0.2-H',
        url='https://www.jst-mfg.com/product/pdf/eng/eSH.pdf?634ed01abb790',
        author='Olle L.',
        rows=1,
        version='1.1',
        create_date='2022-10-18T17:54:12Z')

    save_cache(uuid_cache_file, uuid_cache)
    